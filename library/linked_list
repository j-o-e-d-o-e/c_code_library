linked list

custom data structure

- instead of a size-fixed array
    - `next` points to next elem in list
        - so, each preceding elem stores the address of the following elem
        - if NULL, no next elem (indicating end of list)
    - `head` always points to 1st elem in list
    - `current`: walking pointer
    - `prev`: helper-pointer to the previously visited elem
- useful to allocate mem-space on demand (not in advance)
    - do not forget to counteract each malloc()-call with free()
    - in most envs though, program will free mem automatically when it terminates

- SEE ALSO
    - primer, ch.17
    - /c/linked_list
    - /c/queued_list (FIFO: add only to the end, retrieve only from beginning)

EXAMPLE
struct film {
    char title[20];
    int rating;
    struct film *next;
};

int main(void) {
    struct film *current = (struct film *) malloc(sizeof(struct film));
    struct film *head = current;
    struct film *prev;

    strcpy(current->title, "Cloud Atlas");
    current->rating = 8;
    current->next = NULL; // could be omitted, here

    prev = current;
    current = (struct film *) malloc(sizeof(struct film)); // allocate on demand
    prev->next = current;
    strcpy(current->title, "Donnie Darko");
    current->rating = 9;
    current->next = NULL;

    current = head;
    while (current != NULL) {
        printf("Title: %12s, Rating: %d\n", current->title, current->rating);
        current = current->next;    // Title:  Cloud Atlas, Rating: 8
                                    // Title: Donnie Darko, Rating: 9
    }
    current = head;
    while (current != NULL) {
        free(current);
        current = current->next;
    }
    return 0;
}
