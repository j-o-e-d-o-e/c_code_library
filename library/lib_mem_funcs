lib->mem-funcs



(1) memcpy(void *dest, const void *src, size_t n) [string.h]
    - copies one array to another (of any type due to pointer of type void)
        - n bytes to be copied from memory area src to memory area dest
    - returns pointer to dest
    - assumes no overlap between the two memory ranges
(2) memmove(void *dest, const void *src, size_t n) [string.h]
    - unlike memcpy(), does not make assumption of non-overlapping
(3) memcmp(void *s1, void *s2, size_t n) [string.h]
    - compares two memory areas
    - if s1 less/greater than s2, returns negative/positive int
        - if no difference, returns 0
(4) memchr(void *s, int c, size_t n) [string.h]
    - scans initial n bytes of memory area pointed to by s for c
    - returns pointer to the matching byte or NULL if character does not occur
(5) memset(void *s, int c, size_t n) [string.h]
    - sets n bytes of s to c
    - returns pointer to the memory area s

- SEE ALSO
    - primer, ch.16
    - modern, lvl.1.6
    - beej, ch.11

EXAMPLE
(1)
#define SIZE 3
void print(char *s, const int ar[], int n) {
    printf("%-11s: ", s);
    for (int i = 0; i < n; i++) printf("%d ", ar[i]);
}
int src[SIZE] = {6, 6, 7};
int dest[SIZE];
print("Source", src, SIZE);         // Source     : 6 6 7
memcpy(dest, src, SIZE * sizeof(int));
print("\nDestination", dest, SIZE); // Destination: 6 6 7

(3)
int s1[SIZE] = {6, 6, 7};
int *s2 = (int[SIZE]) {6, 6, 7};
int res = memcmp(s1, s2, SIZE);
printf("Equals? %s", res == 0 ? "true": "false"); // Equals? true

(4)
int s[SIZE] = {6, 6, 7};
int *res = memchr(s, 6, SIZE);
printf("%d", *res);

(5)
char str[SIZE + 1];
strcpy(str,"777");
puts(str);      // 777
memset(str,'6',2);
puts(str);      // 667
